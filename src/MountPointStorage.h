#pragma once

#include <map>
#include <vector>
#include "MountPoint.h"
#include "RegistryStorage.h"

/// 
/// Вспомогательный класс для управления хранилищем описаний ресурсов.

/// Описания ресурсов (класс MountPoint) хранятся в реестре far2l в подпапке
/// папки параметров плагина. Ей соответствует путь в реестре
/// "Software/Far2/gvfspanel/Resources".
///
/// Формат хранилища версионирован. Поддерживается обновление записей более
/// старых форматов в текущий. Номер версии сохраняется в хранилище в ключе
/// "Software/Far2/gvfspanel/Resources/Version". Обновление хранилища, если
/// необходимо, производится при первом к нему обращении на чтение или запись.
///
/// Каждая запись о ресурсе соответствует одной подпапке в папке хранилища.
/// В качестве имени подпапки используется UUID, что гарантирует уникальность
/// ее имени.
///
/// @author cycleg
///
class MountPointStorage: public RegistryStorage
{
  public:
    ///
    /// Конструктор.
    ///
    /// @param registryFolder Имя папки, в которой находится подпапка хранилища
    ///
    /// К указанному в параметре registryFolder пути добавляется суффиксом
    /// значение константы StoragePath.
    ///
    MountPointStorage(const std::wstring& registryFolder);

    ///
    /// Создает новый экземпляр класса MountPoint с заполненным свойством
    /// m_storageId, что необходимо для его дальнейшей сериализации.
    ///
    static MountPoint PointFactory();

    ///
    /// @return Готов или нет экземпляр класса к использованию
    ///
    /// Класс не готов к использованию, если при инициализации не удалось ни
    /// открыть хранилище в реестре, ни создать его.
    /// 
    inline bool valid() const { return m_version != 0; }

    ///
    /// Загрузить все записи из хранилища.
    ///
    /// @param storage Контейнер для вновь загруженных записей
    ///
    /// В качестве ключа в контейнере используется URL ресурса.
    ///
    /// Если версия хранилища не совпадает с текущей поддерживаемой версией,
    /// записи из хранилища обновляются до текущей версии, а затем сохраняются,
    /// обновляя таким образом и само хранилище.
    ///
    /// В ходе загрузки пароль дешифруется методом Decrypt().
    ///
    void LoadAll(std::map<std::wstring, MountPoint>& storage);
    ///
    /// Сохранить запись в хранилище.
    ///
    /// @param point Сохраняемая запись
    /// @return Результат сохранения
    ///
    /// Если версия хранилища не совпадает с текущей поддерживаемой версией,
    /// записи из хранилища обновляются до текущей версии, а затем сохраняются,
    /// обновляя таким образом и само хранилище. Затем сохраняется указанная
    /// запись. Возвращаемое методом значение относится только к этой последней
    /// операции.
    ///
    /// В ходе сохранения пароль шифруется методом Encrypt().
    ///
    bool Save(const MountPoint& point);
    ///
    /// Удалить указанную запись из хранилища.
    ///
    /// @param point Удаляемая запись
    ///
    void Delete(const MountPoint& point) const;

  private:
    static const wchar_t* StoragePath; ///< подпапка реестра, в которой
                                       ///< хранятся записи
    static const wchar_t* StorageVersionKey; ///< имя ключа реестра с версией
                                             ///< формата данных; находится в
                                             ///< той же папке, что и сами
                                             ///< данные
    static const DWORD StorageVersion; ///< текущая поддерживаемая версия
                                       ///< хранилища

    ///
    /// Сгенерировать идентифкатор записи о ресурсе.
    ///
    /// @param id Буфер для нового идентификатора
    /// 
    static void GenerateId(std::wstring& id);
    ///
    /// Закодировать данные.
    ///
    /// @param in Исходные данные
    /// @param out Кодированные данные
    ///
    /// Кодирование очень и очень слабое, настоятельно рекомендуется
    /// использовать версию метода с шифрованием посредством OpenSSL.
    ///
    static void Encrypt(const std::wstring& in, std::vector<BYTE>& out);
#ifdef USE_OPENSSL
    ///
    /// Закодировать данные.
    ///
    /// @param keydata Данные ключа
    /// @param in Исходные данные
    /// @param out Кодированные данные
    ///
    /// Данные шифруются средствами библиотеки libcrypto из OpenSSL.
    ///
    static void Encrypt(const std::wstring& keydata, const std::wstring& in,
                        std::vector<BYTE>& out);
#endif
    // Versioning!

    ///
    /// Декодировать данные.
    ///
    /// @param in Кодированные данные
    /// @param out Восстановленные данные
    ///
    /// Кодирование очень и очень слабое, настоятельно рекомендуется
    /// использовать версию метода с шифрованием посредством OpenSSL.
    ///
    void Decrypt(const std::vector<BYTE>& in, std::wstring& out) const;
#ifdef USE_OPENSSL
    // Versioning!

    ///
    /// Декодировать данные.
    ///
    /// @param keydata Данные ключа
    /// @param in Кодированные данные
    /// @param out Восстановленные данные
    ///
    /// Данные дешифруются средствами библиотеки libcrypto из OpenSSL.
    ///
    void Decrypt(const std::wstring& keydata, const std::vector<BYTE>& in,
                 std::wstring& out) const;
#endif

    // Versioning!

    ///
    /// Загрузить следующую запись из хранилища.
    ///
    /// @param point Буфер для загружаемой записи
    /// @return Результат загрузки
    ///
    /// Возвращает true, если загрузка прошла успешно, false - в прочих
    /// случаях. Если загрузка не удалась, содержимое буфера не меняется.
    ///
    bool Load(MountPoint& point) const;

    DWORD m_version; ///< версия данных, загружаемая из хранилища
};
